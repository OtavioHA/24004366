#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// --- Estruturas de Dados (mantidas) ---

typedef struct No {
    double resistencia_ohms; // Campo de ordenação (em Omega - Oms)
    int quantidade;          // Quantidade de resistores disponíveis
    struct No* prox;         // Ponteiro para o próximo nó
} No;

typedef struct {
    No* inicio;
} Lista;

// --- Funções Auxiliares (mantidas) ---

void inicializar_lista(Lista* L) {
    No* atual = L->inicio;
    No* proximo = NULL;
    while (atual != NULL) {
        proximo = atual->prox;
        free(atual);
        atual = proximo;
    }
    L->inicio = NULL;
    printf("\n>>> A lista foi inicializada/reinicializada com sucesso.\n");
}

void imprimir_resistencia(double resistencia_ohms) {
    if (resistencia_ohms >= 1000000.0) {
        printf("%.2f M", resistencia_ohms / 1000000.0);
    } else if (resistencia_ohms >= 1000.0) {
        printf("%.2f k", resistencia_ohms / 1000.0);
    } else if (resistencia_ohms >= 1.0) {
        printf("%.2f", resistencia_ohms);
    } else if (resistencia_ohms >= 0.001) {
        printf("%.2f m", resistencia_ohms * 1000.0);
    } else {
        printf("%.2e", resistencia_ohms);
    }
}

int lista_vazia(Lista* L) {
    return (L->inicio == NULL);
}

// --- Funções do Menu (funções anteriores mantidas) ---

void inserir(Lista* L) {
    double r;
    int q;

    printf("\n--- Inserir Novo Resistor ---\n");
    printf("Digite o valor da Resistencia (em Ohms): ");
    if (scanf("%lf", &r) != 1 || r <= 0) {
        printf("ERRO: Valor de resistência inválido ou não positivo.\n");
        while (getchar() != '\n');
        return;
    }

    No* atual = L->inicio;
    while (atual != NULL) {
        if (fabs(atual->resistencia_ohms - r) < 1e-9) {
            printf("Resistor de ");
            imprimir_resistencia(r);
            printf(" ja existe. Digite a quantidade a ser ADICIONADA: ");
            if (scanf("%d", &q) != 1 || q < 0) {
                 printf("ERRO: Quantidade invalida.\n");
                 while (getchar() != '\n');
                 return;
            }
            atual->quantidade += q;
            printf(">>> Quantidade atualizada. Nova quantidade: %d\n", atual->quantidade);
            return;
        }
        atual = atual->prox;
    }

    printf("Digite a Quantidade de resistores disponiveis: ");
    if (scanf("%d", &q) != 1 || q < 0) {
         printf("ERRO: Quantidade invalida.\n");
         while (getchar() != '\n');
         return;
    }

    No* novo = (No*)malloc(sizeof(No));
    if (novo == NULL) {
        printf("ERRO: Falha na alocacao de memoria.\n");
        return;
    }
    novo->resistencia_ohms = r;
    novo->quantidade = q;
    novo->prox = NULL;

    No* ant = NULL;
    atual = L->inicio;

    while (atual != NULL && atual->resistencia_ohms < r) {
        ant = atual;
        atual = atual->prox;
    }

    if (ant == NULL) {
        novo->prox = L->inicio;
        L->inicio = novo;
    } else {
        novo->prox = atual;
        ant->prox = novo;
    }

    printf(">>> Novo resistor (");
    imprimir_resistencia(r);
    printf(") inserido com sucesso na lista.\n");
}

void remover(Lista* L) {
    // [código da função remover] ...
    if (lista_vazia(L)) {
        printf("\nERRO: A lista esta vazia. Nao ha o que remover.\n");
        return;
    }

    double r;
    printf("\n--- Remover Tipo de Resistor ---\n");
    printf("Digite o valor da Resistencia (em Ohms) para REMOCAO: ");
    if (scanf("%lf", &r) != 1 || r <= 0) {
        printf("ERRO: Valor de resistência inválido ou não positivo.\n");
        while (getchar() != '\n');
        return;
    }

    No* ant = NULL;
    No* atual = L->inicio;

    while (atual != NULL && fabs(atual->resistencia_ohms - r) > 1e-9) {
        ant = atual;
        atual = atual->prox;
    }

    if (atual == NULL) {
        printf("ERRO: Resistor de ");
        imprimir_resistencia(r);
        printf(" nao encontrado na lista.\n");
    } else {
        if (ant == NULL) {
            L->inicio = atual->prox;
        } else {
            ant->prox = atual->prox;
        }
        printf(">>> Resistor de ");
        imprimir_resistencia(atual->resistencia_ohms);
        printf(" (Quantidade: %d) removido COMPLETAMENTE da lista.\n", atual->quantidade);
        free(atual);
    }
}

void listar(Lista* L) {
    // [código da função listar] ...
    if (lista_vazia(L)) {
        printf("\n--- Lista de Resistores ---\n");
        printf("A lista esta vazia.\n");
        return;
    }

    printf("\n--- Lista Dinamica Ordenada de Resistores ---\n");
    printf("+----------------------+-------------------+\n");
    printf("|     Resistencia      |    Quantidade     |\n");
    printf("+----------------------+-------------------+\n");

    No* atual = L->inicio;
    while (atual != NULL) {
        printf("| ");
        imprimir_resistencia(atual->resistencia_ohms);
        int len = 0;
        if (atual->resistencia_ohms >= 1000000.0) len = 8;
        else if (atual->resistencia_ohms >= 1000.0) len = 7;
        else if (atual->resistencia_ohms >= 1.0) len = 5;
        else if (atual->resistencia_ohms >= 0.001) len = 7;
        else len = 5;

        for (int i = 0; i < 20 - len; i++) {
             printf(" ");
        }

        printf(" | %17d |\n", atual->quantidade);
        atual = atual->prox;
    }
    printf("+----------------------+-------------------+\n");
}

void consultar(Lista* L) {
    // [código da função consultar] ...
    if (lista_vazia(L)) {
        printf("\nERRO: A lista esta vazia.\n");
        return;
    }

    double r;
    printf("\n--- Consultar Estoque ---\n");
    printf("Digite o valor da Resistencia (em Ohms) para consulta: ");
    if (scanf("%lf", &r) != 1 || r <= 0) {
        printf("ERRO: Valor de resistência inválido ou não positivo.\n");
        while (getchar() != '\n');
        return;
    }

    No* atual = L->inicio;
    while (atual != NULL) {
        if (fabs(atual->resistencia_ohms - r) < 1e-9) {
            printf(">>> Resistor de ");
            imprimir_resistencia(r);
            printf(": %d unidades disponiveis.\n", atual->quantidade);
            return;
        }
        atual = atual->prox;
    }

    printf(">>> Resistor de ");
    imprimir_resistencia(r);
    printf(" nao encontrado no estoque.\n");
}

void retirar(Lista* L) {
    // [código da função retirar] ...
    if (lista_vazia(L)) {
        printf("\nERRO: A lista esta vazia.\n");
        return;
    }

    double r;
    int q;
    printf("\n--- Retirar do Estoque ---\n");
    printf("Digite o valor da Resistencia (em Ohms) para retirada: ");
    if (scanf("%lf", &r) != 1 || r <= 0) {
        printf("ERRO: Valor de resistência inválido ou não positivo.\n");
        while (getchar() != '\n');
        return;
    }

    No* atual = L->inicio;
    while (atual != NULL) {
        if (fabs(atual->resistencia_ohms - r) < 1e-9) {
            printf("Resistor de ");
            imprimir_resistencia(r);
            printf(" encontrado. Estoque atual: %d.\n", atual->quantidade);
            printf("Digite a QUANTIDADE a ser retirada: ");
            if (scanf("%d", &q) != 1 || q <= 0) {
                printf("ERRO: Quantidade de retirada invalida (deve ser positiva).\n");
                while (getchar() != '\n');
                return;
            }

            if (q > atual->quantidade) {
                printf("ERRO: Quantidade solicitada (%d) excede o estoque disponivel (%d).\n", q, atual->quantidade);
                return;
            }

            atual->quantidade -= q;
            printf(">>> %d unidades de ", q);
            imprimir_resistencia(r);
            printf(" retiradas com sucesso. Novo estoque: %d.\n", atual->quantidade);

            if (atual->quantidade == 0) {
                printf("AVISO: Estoque de ");
                imprimir_resistencia(r);
                printf(" chegou a zero. Sugerir remocao ou manter na lista.\n");
            }
            return;
        }
        atual = atual->prox;
    }

    printf(">>> Resistor de ");
    imprimir_resistencia(r);
    printf(" nao encontrado no estoque.\n");
}

void repor(Lista* L) {
    // [código da função repor] ...
    if (lista_vazia(L)) {
        printf("\nERRO: A lista esta vazia. Use Inserir para adicionar novos tipos.\n");
        return;
    }

    double r;
    int q;
    printf("\n--- Repor Estoque ---\n");
    printf("Digite o valor da Resistencia (em Ohms) para reposicao: ");
    if (scanf("%lf", &r) != 1 || r <= 0) {
        printf("ERRO: Valor de resistência inválido ou não positivo.\n");
        while (getchar() != '\n');
        return;
    }

    No* atual = L->inicio;
    while (atual != NULL) {
        if (fabs(atual->resistencia_ohms - r) < 1e-9) {
            printf("Resistor de ");
            imprimir_resistencia(r);
            printf(" encontrado. Estoque atual: %d.\n", atual->quantidade);
            printf("Digite a QUANTIDADE a ser reposta: ");
            if (scanf("%d", &q) != 1 || q <= 0) {
                printf("ERRO: Quantidade de reposicao invalida (deve ser positiva).\n");
                while (getchar() != '\n');
                return;
            }

            atual->quantidade += q;
            printf(">>> %d unidades de ", q);
            imprimir_resistencia(r);
            printf(" repostas com sucesso. Novo estoque: %d.\n", atual->quantidade);
            return;
        }
        atual = atual->prox;
    }

    printf(">>> Resistor de ");
    imprimir_resistencia(r);
    printf(" nao encontrado no estoque. Use a opcao 'Inserir' para adiciona-lo.\n");
}

void calcular_resistencia_paralelo() {
    // [código da função calcular_resistencia_paralelo] ...
    double r_atual;
    double soma_inversos = 0.0;
    int contador = 0;

    printf("\n--- Calcular Resistencia Equivalente em Paralelo ---\n");
    printf("Digite a resistencia de cada resistor em Ohms ).\n");
    printf("Digite 0 ou um valor negativo para encerrar a insercao.\n");
    
    while (getchar() != '\n'); // Limpa o buffer de entrada

    while (1) {
        printf("Resistencia %d (Ohms): ", contador + 1);
        if (scanf("%lf", &r_atual) != 1) {
            printf("ERRO: Entrada invalida. Encerrando calculo.\n");
            while (getchar() != '\n');
            break; 
        }

        if (r_atual <= 0.0) {
            break;
        }

        soma_inversos += (1.0 / r_atual);
        contador++;
    }

    printf("--------------------------------------------------\n");

    if (contador < 2) {
        printf("ERRO: E necessario inserir pelo menos dois resistores para o calculo em paralelo.\n");
        return;
    }

    if (soma_inversos == 0.0) {
        printf("ERRO: Soma dos inversos igual a zero. Verifique as entradas.\n");
    } else {
        double r_eq = 1.0 / soma_inversos;

        printf("Resistencia Equivalente (Req) para %d resistores em paralelo:\n", contador);
        printf("Req = 1 / (%.4f S) = ", soma_inversos);
        imprimir_resistencia(r_eq);
        printf("\n");
    }
}


// --- NOVA FUNÇÃO PARA CALCULAR A MÉDIA ---

/**
 * @brief Calcula e exibe a média aritmética das resistências de todos os tipos de resistores na lista.
 * @param L Ponteiro para a lista.
 */
void calcular_media_resistencias(Lista* L) {
    if (lista_vazia(L)) {
        printf("\n--- Calcular Media de Resistencias ---\n");
        printf("ERRO: A lista esta vazia. Nao ha resistores para calcular a media.\n");
        return;
    }

    double soma_resistencias = 0.0;
    int total_tipos = 0;
    
    No* atual = L->inicio;
    
    // Percorre a lista, somando as resistências e contando os tipos
    while (atual != NULL) {
        soma_resistencias += atual->resistencia_ohms;
        total_tipos++;
        atual = atual->prox;
    }
    
    // Calcula a média
    double media = soma_resistencias / total_tipos;

    printf("\n--- Calcular Media de Resistencias ---\n");
    printf("Total de Tipos de Resistores na Lista: %d\n", total_tipos);
    printf("Soma Total das Resistencias (Ohms): %.4f\n", soma_resistencias);
    printf("A Resistencia Media por Tipo e:\n");
    
    printf("Media = ");
    imprimir_resistencia(media);
    printf("\n");
}


// --- Função Principal e Menu (ATUALIZADA) ---

int main() {
    Lista estoque;
    estoque.inicio = NULL;

    int opcao;
    
    printf("--- Iniciando com dados de exemplo ---\n");
    No* n1 = (No*)malloc(sizeof(No)); n1->resistencia_ohms = 10.0; n1->quantidade = 50; n1->prox = NULL;
    No* n2 = (No*)malloc(sizeof(No)); n2->resistencia_ohms = 1000.0; n2->quantidade = 100; n2->prox = NULL;
    No* n3 = (No*)malloc(sizeof(No)); n3->resistencia_ohms = 100000.0; n3->quantidade = 25; n3->prox = NULL;
    
    estoque.inicio = n1;
    n1->prox = n2;
    n2->prox = n3;
    printf("Estoque pre-populado com 1, 1 e 100.\n");

    do {
        printf("\n============================================\n");
        printf("       MENU - GESTAO DE ESTOQUE RESISTORES\n");
        printf("============================================\n");
        printf("[1] Inserir novo tipo de resistor\n");
        printf("[2] Remover completamente um tipo de resistor\n");
        printf("[3] Listar todos os resistores\n");
        printf("[4] Consultar quantidade disponivel\n");
        printf("[5] Retirar uma quantidade do estoque\n");
        printf("[6] Repor uma quantidade no estoque\n");
        printf("[7] Inicializar/Reinicializar a lista\n");
        printf("[8] Calcular Resistencia Equivalente em Paralelo (NOVA FUNCAO)\n");
        printf("[9] Calcular media das resistencias (NOVA FUNCAO)\n"); // Novo item de menu
        printf("[0] Sair do programa\n");
        printf("--------------------------------------------\n");
        printf("Escolha uma opcao: ");

        if (scanf("%d", &opcao) != 1) {
            printf("ERRO: Entrada invalida. Tente novamente.\n");
            while (getchar() != '\n');
            opcao = -1;
            continue;
        }

        switch (opcao) {
            case 1:
                inserir(&estoque);
                break;
            case 2:
                remover(&estoque);
                break;
            case 3:
                listar(&estoque);
                break;
            case 4:
                consultar(&estoque);
                break;
            case 5:
                retirar(&estoque);
                break;
            case 6:
                repor(&estoque);
                break;
            case 7:
                inicializar_lista(&estoque);
                break;
            case 8:
                calcular_resistencia_paralelo();
                break;
            case 9: // Novo Case
                calcular_media_resistencias(&estoque);
                break;
            case 0:
                printf("\nEncerrando o programa. Memoria liberada.\n");
                inicializar_lista(&estoque);
                break;
            default:
                printf("\nOpcao invalida. Por favor, escolha uma opcao valida.\n");
                break;
        }
    } while (opcao != 0);

    return 0;
}
